<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Kirkpatrick-Seidel Algorithm</title>
    <link rel="stylesheet" href="comparison_style.css">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script> 

    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <style>
        #time-calculation h2 {
            margin-bottom: 0px; /* Adjust the margin bottom as needed */
        }
        
    </style>
</head>
<body>
    <header>
        <h1>Comparison of both the Algorithms</h1>
        <nav>
            <ul>
                
            
            <li><a href="main.html">Home</a></li>
            </ul>
        </nav>
        
    </header>
    <main>
        <section id="comparison">
            <h1>Algorithm Comparison: KPS vs. Jarvis March</h1>
            <table border="1">
                <thead>
                    <tr>
                        <th>Aspect</th>
                        <th>KPS Algorithm</th>
                        <th>Jarvis March Algorithm</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Efficiency and Complexity</strong></td>
                        <td>O(nlogh) time complexity. Efficient for large datasets with a small hull relative to input size.</td>
                        <td>O(nh) time complexity. Can be inefficient for large datasets, especially with large hull size.</td>
                    </tr>
                    <tr>
                        <td><strong>Algorithmic Approach</strong></td>
                        <td>Utilizes a divide-and-conquer strategy, solving subproblems independently for faster solutions.</td>
                        <td>Incremental approach by wrapping around points, simple but potentially slower for larger datasets.</td>
                    </tr>
                    <tr>
                        <td><strong>Implementation and Use Cases</strong></td>
                        <td>Complex implementation, suitable for dynamic computational environments with large or frequent updates.</td>
                        <td>Simpler to implement, useful for educational purposes or small datasets where performance is not a concern.</td>
                    </tr>
                    <tr>
                        <td><strong>Best Use Scenarios</strong></td>
                        <td>When performance is crucial with large, dynamic datasets or when hull size is small compared to input size.</td>
                        <td>For smaller datasets or when convex hull comprises a significant portion of points and ease of implementation is valued.</td>
                    </tr>
                </tbody>
            </table>
            <p>
                In summary, the KPS algorithm is generally more efficient and can handle larger datasets better, especially when the convex hull is small relative to the dataset. In contrast, the Jarvis March algorithm is simpler to understand and implement but can become inefficient as the size of the dataset or the convex hull grows.
                </p>
        </section>
      

        <section id="time-calculation">
            <h2>Calculate Expected Runtime</h2>
            <input type="number" id="point-count" min="3" placeholder="Number of points (n)">
            <button onclick="calculateRuntime()">Calculate</button>
            <canvas id="time-complexity-chart" width="800" height="400"></canvas> <!-- Adjust width and height as needed -->
        </section>
        

</main>
<script src="comparison.js"></script>
</body>
</html>