<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>JARVIS MARCH ALGORITHM</title>
        <link rel="stylesheet" href="style.css">
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script>
            MathJax = {
                tex: {
                    inlineMath: [['$', '$'], ['\\(', '\\)']]
                },
                svg: {
                    fontCache: 'global'
                }
            };
        </script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    </head>
<body>
    <header>
        <h1>Jarvis March Algorithm</h1>
        <nav>
            <ul>
                
                <li><a href="jarvis2.html">Introduction</a></li>
                <li><a href="jarvis2.html">Details</a></li>
                <li><a href="jarvis_example.html">Example</a></li>
                <li><a href="#implementation">Implementation</a></li>
                <li><a href="jarvis_references.html">References</a></li>
                <li><a href="main.html">Home</a></li>
                </ul>
        </nav>
    </header>
    <main>
        
        <section id="implementation">
            <h2>Pseudo Code</h2>
            <pre>
            <code>

1. Initialization:
   - Assign `initialPoint` as the first element of the points array.
   - Iterate through each point in the array:
     - Update `initialPoint` if the current point has a smaller x-coordinate (finding the leftmost point).
   - End iteration.

2. Set Initial Point:
   - Set `currentPoint` to `initialPoint`.
   - Add `initialPoint` to the convex hull collection.

3. Prepare for Looping:
   - Initialize an empty set `collinearPoints` to hold points that are collinear with the current segment.

4. Start Looping Process:
   - Begin an indefinite loop.

5. Set Initial Next Target:
   - Assign `nextTarget` to points[0] (assuming the first point will not be `currentPoint`).

6. Iterate Over Points:
   - For each point in the array, excluding `currentPoint`, do the following:
     - Skip if the current point is the same as `currentPoint`.
     - Calculate the cross product of `currentPoint`, `nextTarget`, and the current point.

7. Update Next Target:
   - If the cross product is positive:
     - Update `nextTarget` to be the current point.
     - Clear the `collinearPoints` set.
   - Else if the cross product is zero (collinear):
     - Check if `nextTarget` is closer to `currentPoint` than the current point.
     - If closer, add `nextTarget` to `collinearPoints` and update `nextTarget` to the current point.
     - Otherwise, add the current point to `collinearPoints`.
   - End for loop.

8. Check Loop Termination:
   - Add all points from `collinearPoints` to the convex hull collection.
   - If `nextTarget` is the same as `initialPoint`, then terminate the loop.

9. Update for Next Iteration:
   - Add `nextTarget` to the convex hull collection.
   - Update `currentPoint` to `nextTarget`.
   - End Loop.

10. Return Result:
    - Return the convex hull collection.
            </code>
            </pre>
            
        </section>
        <section id="time-complexity" >
            <h2>Time Complexity Analysis</h2>
            
            <h3> 1. Overview:</h3>
    <p>
        The time complexity of the Jarvis March algorithm is \(O(nh)\), where:
        <ul>
            <li>\(n\) is the total number of points in the input set.</li>
            <li>\(h\) is the number of points on the convex hull.</li>
        </ul>
    </p>
    <br>
    <h3> 2. Justification:</h3>
    <br>
    <p>
        <ul>
            <li><strong>Collecting Input Points:</strong> The algorithm begins by accepting point inputs from the user, which is a linear operation, O(n), based on the number of points the user enters.</li>
            <li><strong>Finding the Leftmost Point: </strong>The algorithm then finds the leftmost point to start the convex hull construction. This step is also linear, O(n), as it involves iterating over all input points to find the minimum x-coordinate.</li>
            <li><strong>Main Loop for Hull Construction:</strong>Once the leftmost point is identified, the algorithm enters a loop that potentially goes through n iterations to construct the convex hull. Each iteration involves comparing points to find the next point on the hull using a cross product operation, which is O(n) for each hull point in the worst case. </li>
        </ul>
    </p>
    <br>

    <h3> 3. Total Time Complexity:</h3>
    <p>
        Given that the algorithm may iterate through all points for each of the h hull points, the total time complexity is O(nh).    </p>
    <br>
    <h3> 4. Best and Worst Case:</h3>
    <br>
    <p>
        <ul>
            <li><strong>Best case scenario</strong> This occurs when the number of hull points h is minimal. For instance, when all points are collinear, h could be as low as 2. However, the algorithm still needs to iterate through all points to confirm collinearity, maintaining an O(n) complexity.</li>
            <li><strong>Worst case scenario</strong> This occurs when the number of hull points h is maximal relative to n. If many points or all points are part of the convex hull (h ≈ n), the time complexity becomes O(n^2).</li>
        </ul>
    </p>
    <br>
    <h3> 5. Space Complexity:</h3>
    <p>
        The space complexity of the algorithm is O(h) because it stores the points that make up the convex hull. No additional significant space is needed beyond what is required for the input and the output hull storage.
    </p>
    <br>
    <h3>Conclusion:</h3>
    <p>
        The Jarvis March algorithm's time complexity of \(O(nh)\) makes it particularly suited for scenarios where the number of hull points (\(h\)) is much smaller than the total number of points (\(n\)). However, for datasets where \(h\) approaches \(n\), the algorithm can become inefficient compared to other convex hull algorithms like Graham's scan, which operates in \(O(n \log n)\) time irrespective of \(h\).
    </p>
        </section>
         

        

    </main>
    <footer>
        <p>Documentation created by Chinmay, Dev, Parth and Harsh. © 2024</p>
    </footer>
</body>
</html>